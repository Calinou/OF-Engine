import std
import std.package

import std.conv

from std.conv import tonumber, tostring
from std.table import pairs

/* SERIALIZER */

var serialize_fn
serialize_fn = func(v, stream, kwargs, simp, tables, indent)
    if simp do
        v = simp(v)
    end
    var tv = typeof v
    if tv == "string" do
        stream(v.escape())
    elif tv == "number" or tv == "boolean" or tv == "undef" do
        stream(tostring(v))
    elif tv == "table" do
        var mline   = kwargs.multiline
        var indstr  = kwargs.indent
        var asstr   = kwargs.assign or ":"
        var sepstr  = kwargs.table_sep or ","
        var isepstr = kwargs.item_sep
        var endsep  = kwargs.end_sep
        var optk    = kwargs.optimize_keys
        var nline   = kwargs.nrec_line or 0
        if tables[v] do
            stream() // let the stream know about an error
            return false,
                "circular table reference detected during serialization"
        end
        tables[v] = true
        stream("{")
        if mline do stream("\n") end
        var first = true
        var n = 0
        for k, v in pairs(v) do
            if first do first = false
            else
                stream(sepstr)
                if mline do
                    if n == 0 do
                        stream("\n")
                    elif isepstr do
                        stream(isepstr)
                    end
                end
            end
            if mline and indstr and n == 0 do
                for i in 1 to indent do stream(indstr) end
            end
            var tk = typeof k
            if optk and tk == "string"
            and k.find_match("^[%a_][%w_]*$") do
                stream(k)
            elif tk == "string" or tk == "number" or tk == "boolean" do
                var ret, err = serialize_fn(k, stream, kwargs, simp,
                    tables, indent + 1)
                if not ret do return ret, err end
            else
                stream("(")
                var ret, err = serialize_fn(k, stream, kwargs, simp,
                    tables, indent + 1)
                if not ret do return ret, err end
                stream(")")
            end
            stream(asstr)
            var ret, err = serialize_fn(v, stream, kwargs, simp, tables,
                indent + 1)
            if not ret do return ret, err end
            n = (n + 1) % nline
        end
        if not first do
            if endsep do stream(sepstr) end
            if mline do stream("\n") end
        end
        if mline and indstr do
            for i in 2 to indent do stream(indstr) end
        end
        stream("}")
    elif tv == "array" do
        var mline   = kwargs.multiline
        var indstr  = kwargs.indent
        var sepstr  = kwargs.array_sep or ","
        var isepstr = kwargs.item_sep
        var endsep  = kwargs.end_sep
        var nline   = kwargs.narr_line or 0
        if tables[v] do
            stream() // let the stream know about an error
            return false,
                "circular array reference detected during serialization"
        end
        tables[v] = true
        stream("[")
        if mline do stream("\n") end
        var first = true
        var n = 0
        for i, v in v.each() do
            if first do first = false
            else
                stream(sepstr)
                if mline do
                    if n == 0 do
                        stream("\n")
                    elif isepstr do
                        stream(isepstr)
                    end
                end
            end
            if mline and indstr and n == 0 do
                for i in 1 to indent do stream(indstr) end
            end
            var ret, err = serialize_fn(v, stream, kwargs, simp, tables,
                indent + 1)
            if not ret do return ret, err end
            n = (n + 1) % nline
        end
        if not first do
            if endsep do stream(sepstr) end
            if mline do stream("\n") end
        end
        if mline and indstr do
            for i in 2 to indent do stream(indstr) end
        end
        stream("]")
    else
        stream()
        return false, ("invalid value type: " ~ tv)
    end
    return true
end

var defkw = {
    multiline: false, indent: undef, assign: ":", table_sep: ",",
    array_sep: ",", end_sep: false, optimize_keys: true
}

var defkwp = {
    multiline: true, indent: "    ", assign: ": ", table_sep: ",",
    array_sep: ", ", item_sep: " ", narr_line: 4, nrec_line: 2,
    end_sep: false, optimize_keys: true
}

/**
    Serializes a given table, returning a string containing a literal
    representation of the table. It tries to be compact by default so it
    avoids whitespace and newlines. Arrays and associative arrays are
    serialized differently (for compact output).

    Besides tables this can also serialize other OctaScript values. It
    serializes them in the same way as values inside a table, returning their
    literal representation (if serializable, otherwise just their tostring).
    The serializer allows strings, numbers, booleans and tables.

    Circular tables can't be serialized. The function normally returns either
    the string output or undef + an error message (which can signalize either
    circular references or invalid types).

    The function allows you to pass in a "kwargs" table as the second argument.
    It's a table of options. Those can be multiline (boolean, false by default,
    pretty much pretty-printing), indent (string, undef by default, specifies
    how an indent level looks), assign (string, "=" by default, specifies how
    an assignment between a key and a value looks), table_sep (table separator,
    by default ",", can also be ";" for tables, separates items in all cases),
    array_sep (array item separator, by default ","), item_sep (item separator,
    string, undef by default, comes after array_sep/table_sep but only if it
    isn't followed by a newline), narr_line (number, 0 by default, how many
    array elements to fit on a line), nrec_line (same, just for key-value
    pairs), end_sep (boolean, false by default, makes the serializer put
    array_sep or table_sep after every item including the last one),
    optimize_keys (boolean, true by default, optimizes string keys like that
    it doesn't use string literals for keys that can be expressed as OctaScript
    names).

    If kwargs is undef or false, the values above are used. If kwargs is a
    boolean value true, pretty-printing defaults are used (multiline is
    true, indent is 4 spaces, assign is " = ", table_sep is ",", array_sep is
    "," item_sep is one space, narr_line is 4, nrec_line is 2, end_sep is
    false, optimize_keys is true).

    Arguments:
        - val - the value to serialize.
        - kwargs - see above.
        - stream - optionally a function that is called every time a new piece
          is saved - when a custom stream is supplied, the function doesn't
          return a string, but it returns true or false depending on whether
          it succeeded and a potential error message.
        - simplifier - optionally a function that takes a value and simplifies
          it (returns another value the original should be replaced with),
          by default there is no simplifier.
*/
conv.serialize = func(val, kwargs, stream, simplifier)
    if kwargs == true do
        kwargs = defkwp
    elif not kwargs do
        kwargs = defkw
    else
        if  kwargs.optimize_keys == undef do
            kwargs.optimize_keys = true
        end
    end
    if stream do
        return serialize_fn(val, stream, kwargs, simplifier, {}, 1)
    else
        var t = []
        var ret, err = serialize_fn(val, func(out) t.push(out) end,
            kwargs, simplifier, {}, 1)
        if not ret do
            return undef, err
        else
            return t.concat()
        end
    end
end

var lex_get = func(ls)
    while true do
        var c = ls.curr
        if not c do break end
        ls.tname, ls.tval = undef, undef
        if c == "\n" or c == "\r" do
            var prev = c
            c = ls::rdr()
            if (c == "\n" or c == "\r") and c != prev do
                c = ls::rdr()
            end
            ls.curr = c
            ls.linenum = ls.linenum + 1
        elif c == " " or c == "\t" or c == "\f" or c == "\v" do
            ls.curr = ls::rdr()
        elif c == "." or c.byte() >= 48 and c.byte() <= 57 do
            var buf = [ ls.curr ]
            ls.curr = ls::rdr()
            while ls.curr and ls.curr.find_match("[epxEPX0-9.+-]") do
                buf.push(ls.curr)
                ls.curr = ls::rdr()
            end
            var str = buf.concat()
            var num = tonumber(str)
            if not num do raise ("%d: malformed number near '%s'")
                .format(ls.linenum, str), 0 end
            ls.tname, ls.tval = "<number>", num
            return "<number>"
        elif c == '"' or c == "'" do
            var d = ls.curr
            ls.curr = ls::rdr()
            var buf = []
            while ls.curr != d do
                var c = ls.curr
                if c == undef do
                    raise ("%d: unfinished string near '<eos>'")
                        .format(ls.linenum), 0
                elif c == "\n" or c == "\r" do
                    raise ("%d: unfinished string near '<string>'")
                        .format(ls.linenum), 0
                // not complete escape sequence handling: handles only these
                // that are or can be in the serialized output
                elif c == "\\" do
                    c = ls::rdr()
                    if c == "a" do
                        buf.push("\a") ls.curr = ls::rdr()
                    elif c == "b" do
                        buf.push("\b") ls.curr = ls::rdr()
                    elif c == "f" do
                        buf.push("\f") ls.curr = ls::rdr()
                    elif c == "n" do
                        buf.push("\n") ls.curr = ls::rdr()
                    elif c == "r" do
                        buf.push("\r") ls.curr = ls::rdr()
                    elif c == "t" do
                        buf.push("\t") ls.curr = ls::rdr()
                    elif c == "v" do
                        buf.push("\v")ls.curr = ls::rdr()
                    elif c == "\\" or c == '"' or c == "'" do
                        buf.push(c)
                        ls.curr = ls::rdr()
                    elif not c do
                        raise ("%d: unfinished string near '<eos>'")
                            .format(ls.linenum), 0
                    else
                        if not c.find_match("%d") do
                            raise ("%d: invalid escape sequence")
                                .format(ls.linenum), 0
                        end
                        var dbuf = [ c ]
                        c = ls::rdr()
                        if c.find_match("%d") do
                            dbuf.push(c)
                            c = ls::rdr()
                            if c.find_match("%d") do
                                dbuf.push(c)
                                c = ls::rdr()
                            end
                        end
                        ls.curr = c
                        buf.push(dbuf.concat().char())
                    end
                else
                    buf.push(c)
                    ls.curr = ls::rdr()
                end
            end
            ls.curr = ls::rdr() // skip delim
            ls.tname, ls.tval = "<string>", buf.concat()
            return "<string>"
        elif c.find_match("[%a_]") do
            var buf = [ c ]
            ls.curr = ls::rdr()
            while ls.curr and ls.curr.find_match("[%w_]") do
                buf.push(ls.curr)
                ls.curr = ls::rdr()
            end
            var str = buf.concat()
            if str == "true" or str == "false" or str == "undef" do
                ls.tname, ls.tval = str, undef
                return str
            else
                ls.tname, ls.tval = "<name>", str
                return "<name>"
            end
        else
            ls.curr = ls::rdr()
            ls.tname, ls.tval = c, undef
            return c
        end
    end
end

var assert_tok
assert_tok = func(ls, tok, ...)
    if not tok do return end
    if ls.tname != tok do
        raise ("%d: unexpected symbol near '%s'").format(ls.linenum, ls.tname), 0
    end
    lex_get(ls)
    assert_tok(ls, ...)
end

var allowed_keys = { "<number>": true, "<string>": true, "true": true,
    "false": true, "null": true }

var parse
parse = func(ls)
    var tok = ls.tname
    if tok == "<string>" or tok == "<number>" do
        var v = ls.tval
        lex_get(ls)
        return v
    elif tok == "true"  do lex_get(ls) return true
    elif tok == "false" do lex_get(ls) return false
    elif tok == "undef" do lex_get(ls) return undef
    elif tok == "null"  do lex_get(ls) return null
    elif tok == "[" do
        lex_get(ls)
        var ret = []
        if ls.tname == "]" do
            lex_get(ls)
            return ret
        end
        repeat
            ret.push(parse(ls))
        until ls.tname != "," or not lex_get(ls)
        assert_tok(ls, "]")
        return ret
    else
        assert_tok(ls, "{")
        var tbl = {}
        if ls.tname == "}" do
            lex_get(ls)
            return tbl
        end
        var arri = 1
        repeat
            var key
            if ls.tname == "<name>" do
                key = ls.tval
                lex_get(ls)
            elif allowed_keys[ls.tname] do
                key = parse(ls)
            else
                assert_tok(ls, "(")
                key = parse(ls)
                assert_tok(ls, ")")
            end
            assert_tok(ls, ":")
            tbl[key] = parse(ls)
        until (ls.tname != "," and ls.tname != ";") or not lex_get(ls)
        assert_tok(ls, "}")
        return tbl
    end
end

/**
    Takes a previously serialized table and converts it back to the original.
    Uses a simple tokenizer and a recursive descent parser to build the result
    so it's safe (doesn't evaluate anything). The input can also be a callable
    value that return the next character each call.
    This returns the deserialized value on success and undef + the error
    message on failure.
*/
conv.deserialize = func(s)
    var stream = (typeof s == "string") and s.gmatch(".") or s
    var ls = { curr: stream(), rdr: stream, linenum: 1 }
    var r, v = try lex_get(ls)
    if not r do return undef, v end
    r, v = try parse(ls)
    if not r do return undef, v end
    return v
end