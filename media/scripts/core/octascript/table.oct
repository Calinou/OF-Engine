/**<
    OctaScript table extensions.

    Author:
        q66 <quaker66@gmail.com>

    License:
        See COPYING.txt.
*/

import capi

from core.externals import set as ext_set

from std.conv import tonumber, tostring
from std.math import floor, log
from std.table import pairs

import std.table

/**
    Merges two associative arrays (maps). When a key overlaps, the latter
    value is preferred.
*/
table.merge = func(ta, tb)
    var r = {}
    for a, b in pairs(ta) do r[a] = b end
    for a, b in pairs(tb) do r[a] = b end
    return r
end

/**
    Returns a copy of the given table. It's a shallow copy.
*/
table.copy = func(t)
    var r = {}
    for a, b in pairs(t) do r[a] = b end
    return r
end

/**
    Filters a map.

    ```
    // a table to filter
    foo = { a = 5, b = 10, c = 15, d = 20 }
    // the filtered table, contains just key/value pairs a, b, d
    bar = filter_map(foo, func(k, v)
        if k == "c" do
            return false
        else
            return true
        end
    end)
    ```
*/
table.filter = func(t, f)
    var r = {}
    for a, b in pairs(t) do if f(a, b) do r[a] = b end end
    return r
end

var serialize_fn
serialize_fn = func(v, stream, kwargs, simp, tables, indent)
    if simp do
        v = simp(v)
    end
    var tv = typeof v
    if tv == "string" do
        stream(v.escape())
    elif tv == "number" or tv == "boolean" or tv == "undef" do
        stream(tostring(v))
    elif tv == "table" do
        var mline   = kwargs.multiline
        var indstr  = kwargs.indent
        var asstr   = kwargs.assign or ":"
        var sepstr  = kwargs.table_sep or ","
        var isepstr = kwargs.item_sep
        var endsep  = kwargs.end_sep
        var optk    = kwargs.optimize_keys
        var nline   = kwargs.nrec_line or 0
        if tables[v] do
            stream() // let the stream know about an error
            return false,
                "circular table reference detected during serialization"
        end
        tables[v] = true
        stream("{")
        if mline do stream("\n") end
        var first = true
        var n = 0
        for k, v in pairs(v) do
            if first do first = false
            else
                stream(sepstr)
                if mline do
                    if n == 0 do
                        stream("\n")
                    elif isepstr do
                        stream(isepstr)
                    end
                end
            end
            if mline and indstr and n == 0 do
                for i in 1 to indent do stream(indstr) end
            end
            var tk = typeof k
            if optk and tk == "string"
            and k.find_match("^[%a_][%w_]*$") do
                stream(k)
            elif tk == "string" or tk == "number" or tk == "boolean" do
                var ret, err = serialize_fn(k, stream, kwargs, simp,
                    tables, indent + 1)
                if not ret do return ret, err end
            else
                stream("$(")
                var ret, err = serialize_fn(k, stream, kwargs, simp,
                    tables, indent + 1)
                if not ret do return ret, err end
                stream(")")
            end
            stream(asstr)
            var ret, err = serialize_fn(v, stream, kwargs, simp, tables,
                indent + 1)
            if not ret do return ret, err end
            n = (n + 1) % nline
        end
        if not first do
            if endsep do stream(sepstr) end
            if mline do stream("\n") end
        end
        if mline and indstr do
            for i in 2 to indent do stream(indstr) end
        end
        stream("}")
    elif tv == "array" do
        var mline   = kwargs.multiline
        var indstr  = kwargs.indent
        var sepstr  = kwargs.array_sep or ","
        var isepstr = kwargs.item_sep
        var endsep  = kwargs.end_sep
        var nline   = kwargs.narr_line or 0
        if tables[v] do
            stream() // let the stream know about an error
            return false,
                "circular array reference detected during serialization"
        end
        tables[v] = true
        stream("[")
        if mline do stream("\n") end
        var first = true
        var n = 0
        for i, v in v.each() do
            if first do first = false
            else
                stream(sepstr)
                if mline do
                    if n == 0 do
                        stream("\n")
                    elif isepstr do
                        stream(isepstr)
                    end
                end
            end
            if mline and indstr and n == 0 do
                for i in 1 to indent do stream(indstr) end
            end
            var ret, err = serialize_fn(v, stream, kwargs, simp, tables,
                indent + 1)
            if not ret do return ret, err end
            n = (n + 1) % nline
        end
        if not first do
            if endsep do stream(sepstr) end
            if mline do stream("\n") end
        end
        if mline and indstr do
            for i in 2 to indent do stream(indstr) end
        end
        stream("]")
    else
        stream()
        return false, ("invalid value type: " ~ tv)
    end
    return true
end

var defkw = {
    multiline: false, indent: undef, assign: ":", table_sep: ",",
    array_sep: ",", end_sep: false, optimize_keys: true
}

var defkwp = {
    multiline: true, indent: "    ", assign: ": ", table_sep: ",",
    array_sep: ", ", item_sep: " ", narr_line: 4, nrec_line: 2,
    end_sep: false, optimize_keys: true
}

/**
    Serializes a given table, returning a string containing a literal
    representation of the table. It tries to be compact by default so it
    avoids whitespace and newlines. Arrays and associative arrays are
    serialized differently (for compact output).

    Besides tables this can also serialize other OctaScript values. It
    serializes them in the same way as values inside a table, returning their
    literal representation (if serializable, otherwise just their tostring).
    The serializer allows strings, numbers, booleans and tables.

    Circular tables can't be serialized. The function normally returns either
    the string output or undef + an error message (which can signalize either
    circular references or invalid types).

    The function allows you to pass in a "kwargs" table as the second argument.
    It's a table of options. Those can be multiline (boolean, false by default,
    pretty much pretty-printing), indent (string, undef by default, specifies
    how an indent level looks), assign (string, "=" by default, specifies how
    an assignment between a key and a value looks), table_sep (table separator,
    by default ",", can also be ";" for tables, separates items in all cases),
    array_sep (array item separator, by default ","), item_sep (item separator,
    string, undef by default, comes after array_sep/table_sep but only if it
    isn't followed by a newline), narr_line (number, 0 by default, how many
    array elements to fit on a line), nrec_line (same, just for key-value
    pairs), end_sep (boolean, false by default, makes the serializer put
    array_sep or table_sep after every item including the last one),
    optimize_keys (boolean, true by default, optimizes string keys like that
    it doesn't use string literals for keys that can be expressed as OctaScript
    names).

    If kwargs is undef or false, the values above are used. If kwargs is a
    boolean value true, pretty-printing defaults are used (multiline is
    true, indent is 4 spaces, assign is " = ", table_sep is ",", array_sep is
    "," item_sep is one space, narr_line is 4, nrec_line is 2, end_sep is
    false, optimize_keys is true).

    This function is externally available as "table_serialize".

    Arguments:
        - val - the value to serialize.
        - kwargs - see above.
        - stream - optionally a function that is called every time a new piece
          is saved - when a custom stream is supplied, the function doesn't
          return a string, but it returns true or false depending on whether
          it succeeded and a potential error message.
        - simplifier - optionally a function that takes a value and simplifies
          it (returns another value the original should be replaced with),
          by default there is no simplifier.
*/
var serialize = func(val, kwargs, stream, simplifier)
    if kwargs == true do
        kwargs = defkwp
    elif not kwargs do
        kwargs = defkw
    else
        if  kwargs.optimize_keys == undef do
            kwargs.optimize_keys = true
        end
    end
    if stream do
        return serialize_fn(val, stream, kwargs, simplifier, {}, 1)
    else
        var t = []
        var ret, err = serialize_fn(val, func(out) t.push(out) end,
            kwargs, simplifier, {}, 1)
        if not ret do
            return undef, err
        else
            return t.concat()
        end
    end
end
table.serialize = serialize
ext_set("table_serialize", serialize)

var lex_get = func(ls)
    while true do
        var c = ls.curr
        if not c do break end
        ls.tname, ls.tval = undef, undef
        if c == "\n" or c == "\r" do
            var prev = c
            c = ls::rdr()
            if (c == "\n" or c == "\r") and c != prev do
                c = ls::rdr()
            end
            ls.curr = c
            ls.linenum = ls.linenum + 1
        elif c == " " or c == "\t" or c == "\f" or c == "\v" do
            ls.curr = ls::rdr()
        elif c == "." or c.byte() >= 48 and c.byte() <= 57 do
            var buf = [ ls.curr ]
            ls.curr = ls::rdr()
            while ls.curr and ls.curr.find_match("[epxEPX0-9.+-]") do
                buf.push(ls.curr)
                ls.curr = ls::rdr()
            end
            var str = buf.concat()
            var num = tonumber(str)
            if not num do raise ("%d: malformed number near '%s'")
                .format(ls.linenum, str), 0 end
            ls.tname, ls.tval = "<number>", num
            return "<number>"
        elif c == '"' or c == "'" do
            var d = ls.curr
            ls.curr = ls::rdr()
            var buf = []
            while ls.curr != d do
                var c = ls.curr
                if c == undef do
                    raise ("%d: unfinished string near '<eos>'")
                        .format(ls.linenum), 0
                elif c == "\n" or c == "\r" do
                    raise ("%d: unfinished string near '<string>'")
                        .format(ls.linenum), 0
                // not complete escape sequence handling: handles only these
                // that are or can be in the serialized output
                elif c == "\\" do
                    c = ls::rdr()
                    if c == "a" do
                        buf.push("\a") ls.curr = ls::rdr()
                    elif c == "b" do
                        buf.push("\b") ls.curr = ls::rdr()
                    elif c == "f" do
                        buf.push("\f") ls.curr = ls::rdr()
                    elif c == "n" do
                        buf.push("\n") ls.curr = ls::rdr()
                    elif c == "r" do
                        buf.push("\r") ls.curr = ls::rdr()
                    elif c == "t" do
                        buf.push("\t") ls.curr = ls::rdr()
                    elif c == "v" do
                        buf.push("\v")ls.curr = ls::rdr()
                    elif c == "\\" or c == '"' or c == "'" do
                        buf.push(c)
                        ls.curr = ls::rdr()
                    elif not c do
                        raise ("%d: unfinished string near '<eos>'")
                            .format(ls.linenum), 0
                    else
                        if not c.find_match("%d") do
                            raise ("%d: invalid escape sequence")
                                .format(ls.linenum), 0
                        end
                        var dbuf = [ c ]
                        c = ls::rdr()
                        if c.find_match("%d") do
                            dbuf.push(c)
                            c = ls::rdr()
                            if c.find_match("%d") do
                                dbuf.push(c)
                                c = ls::rdr()
                            end
                        end
                        ls.curr = c
                        buf.push(dbuf.concat().char())
                    end
                else
                    buf.push(c)
                    ls.curr = ls::rdr()
                end
            end
            ls.curr = ls::rdr() // skip delim
            ls.tname, ls.tval = "<string>", buf.concat()
            return "<string>"
        elif c.find_match("[%a_]") do
            var buf = [ c ]
            ls.curr = ls::rdr()
            while ls.curr and ls.curr.find_match("[%w_]") do
                buf.push(ls.curr)
                ls.curr = ls::rdr()
            end
            var str = buf.concat()
            if str == "true" or str == "false" or str == "undef" do
                ls.tname, ls.tval = str, undef
                return str
            else
                ls.tname, ls.tval = "<name>", str
                return "<name>"
            end
        else
            ls.curr = ls::rdr()
            ls.tname, ls.tval = c, undef
            return c
        end
    end
end

var assert_tok
assert_tok = func(ls, tok, ...)
    if not tok do return end
    if ls.tname != tok do
        raise ("%d: unexpected symbol near '%s'").format(ls.linenum, ls.tname), 0
    end
    lex_get(ls)
    assert_tok(ls, ...)
end

var allowed_keys = { "<number>": true, "<string>": true, "true": true,
    "false": true, "null": true }

var parse
parse = func(ls)
    var tok = ls.tname
    if tok == "<string>" or tok == "<number>" do
        var v = ls.tval
        lex_get(ls)
        return v
    elif tok == "true"  do lex_get(ls) return true
    elif tok == "false" do lex_get(ls) return false
    elif tok == "undef" do lex_get(ls) return undef
    elif tok == "null"  do lex_get(ls) return null
    elif tok == "[" do
        lex_get(ls)
        var ret = []
        if ls.tname == "]" do
            lex_get(ls)
            return ret
        end
        repeat
            ret.push(parse(ls))
        until ls.tname != "," or not lex_get(ls)
        assert_tok(ls, "]")
        return ret
    else
        assert_tok(ls, "{")
        var tbl = {}
        if ls.tname == "}" do
            lex_get(ls)
            return tbl
        end
        var arri = 1
        repeat
            var key
            if ls.tname == "<name>" do
                key = ls.tval
                lex_get(ls)
            elif allowed_keys[ls.tname] do
                key = parse(ls)
            else
                assert_tok(ls, "$")
                assert_tok(ls, "(")
                key = parse(ls)
                assert_tok(ls, ")")
            end
            assert_tok(ls, ":")
            tbl[key] = parse(ls)
        until (ls.tname != "," and ls.tname != ";") or not lex_get(ls)
        assert_tok(ls, "}")
        return tbl
    end
end

/**
    Takes a previously serialized table and converts it back to the original.
    Uses a simple tokenizer and a recursive descent parser to build the result
    so it's safe (doesn't evaluate anything). The input can also be a callable
    value that return the next character each call.
    External as "table_deserialize". This returns the deserialized value on
    success and undef + the error message on failure.
*/
table.deserialize = func(s)
    var stream = (typeof s == "string") and s.gmatch(".") or s
    var ls = { curr: stream(), rdr: stream, linenum: 1 }
    var r, v = try lex_get(ls)
    if not r do return undef, v end
    r, v = try parse(ls)
    if not r do return undef, v end
    return v
end
ext_set("table_deserialize", table.deserialize)

var sift_down = func(tbl, l, s, e, fun)
    var root = s
    while root * 2 - l + 1 <= e do
        var child = root * 2 - l + 1
        var swap  = root
        if fun(tbl[swap], tbl[child]) do
            swap = child
        end
        if child + 1 <= e and fun(tbl[swap], tbl[child + 1]) do
            swap = child + 1
        end
        if swap != root do
            tbl[root], tbl[swap] = tbl[swap], tbl[root]
            root = swap
        else return end
    end
end

var heapsort = func(tbl, l, r, fun)
    var start = floor((l + r) / 2)
    while start >= l do
        sift_down(tbl, l, start, r, fun)
        start = start - 1
    end
    var e = r
    while e > l do
        tbl[e], tbl[l] = tbl[l], tbl[e]
        e = e - 1
        sift_down(tbl, l, l, e, fun)
    end
end

var partition = func(tbl, l, r, pidx, fun)
    var pivot = tbl[pidx]
    tbl[pidx], tbl[r] = tbl[r], tbl[pidx]
    for i in l to r - 1 do
        if fun(tbl[i], pivot) do
            tbl[i], tbl[l] = tbl[l], tbl[i]
            l = l + 1
        end
    end
    tbl[l], tbl[r] = tbl[r], tbl[l]
    return l
end

var insertion_sort = func(tbl, l, r, fun)
    for i in l to r do
        var j, v = i, tbl[i]
        while j > 1 and not fun(tbl[j - 1], v) do
            tbl[j] = tbl[j - 1]
            j = j - 1
        end
        tbl[j] = v
    end
end

var introloop
introloop = func(tbl, l, r, depth, fun)
    if (r - l) > 10 do
        if depth == 0 do
            return heapsort(tbl, l, r, fun)
        end
        var pidx = partition(tbl, l, r, floor((l + r) / 2), fun)
        introloop(tbl, l, pidx - 1, depth - 1, fun)
        introloop(tbl, pidx + 1, r, depth - 1, fun)
    else insertion_sort(tbl, l, r, fun) end
end

var introsort = func(tbl, l, r, fun)
    return introloop(tbl, l, r, 2 * floor(log(r - l + 1) / log(2)), fun)
end

var defaultcmp = func(a, b) return a < b end

import std.array

/**
    The sorting algorithm used here is introsort. It's a modification
    of quicksort that switches to heapsort when the recursion depth
    exceeds 2 * floor(log(nitems) / log(2)). It also uses insertion
    sort to sort small sublists (10 elements and smaller). The
    quicksort part uses a median of three pivot.

    The l and r default to 0 and x.len() - 1 respectively. You can override
    them to sort any kind of structure, even one that doesn't provide a len
    method or one that is 1-indexed. The deafult comparison function uses the
    "less than" operator.
*/
array.sort = func(self, fun, l, r)
    l, r = l or 0, r or self.len() - 1
    return introsort(self, l, r, fun or defaultcmp)
end

//
// Object system
//

from std.table import setmt

/**
    Provides the basis for any object in OF. It implements a simple prototypal
    OO system.
*/
table.Object = {
    /**
        When you call an object, it's identical to $clone, but it also
        tries to call a __ctor field of the current object on the result,
        passing in any extra arguments (besides the new object as the first
        argument).
    */
    __call: func(self, ...)
        var r = {
            __index: self, __proto: self, __call: self.__call,
            __tostring: self.__tostring
        }
        setmt(r, r)
        if self.__ctor do self::__ctor(r, ...) end
        return r
    end,

    /**
        "Clones" an object. It's not an actual clone as it's delegative
        (doesn't copy, only hooks a metatable). Thanks to its delegative
        nature changes in parents also reflect in children.

        Arguments:
            tbl - optionally a table to serve as a basis for the new clone
            (this will modify the table and hook its metatable properly).

        Returns:
            The new clone.
    */
    clone: func(self, tbl)
        tbl = tbl or {}
        tbl.__index, tbl.__proto, tbl.__call = self, self, self.__call
        if not tbl.__tostring do tbl.__tostring = self.__tostring end
        setmt(tbl, tbl)
        return tbl
    end,

    /**
        Checks whether the current object is a either equal to the given
        object, is a child of the given object, or a child of a child
        of the given object, or anything down the tree.
    */
    is_a: func(self, base)
        if self == base do return true end
        var pt = self.__proto
        var is = (pt == base)
        while not is and pt do
            pt = pt.__proto
            is = (pt == base)
        end
        return is
    end,

    /**
        The default tostring result is in format "Object: NAME" where NAME
        is self.name.
    */
    __tostring: func(self)
        return ("Object: %s").format(self.name or "unnamed")
    end
}
