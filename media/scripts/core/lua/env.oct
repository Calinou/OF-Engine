/**<
    Provides environment management for sandboxed scripts.

    Author:
        q66 <quaker66@gmail.com>

    License:
        See COPYING.txt.
*/

import core.logger
import core.lua.stream

import std.table

/// Module: env
var M = {}

var env_package = {
    preload = {}
}

var assert  = assert
var setfenv = setfenv
var tconc   = table.concat

env_package.loaders = {
    func(modname)
        var  v = env_package.preload[modname]
        if not v do
            return ("\tno field package.preload['%s']"):format(modname)
        end
        return v
    end,
    package.loaders[2]
}

var find_loader = func(modname, env)
    env = env or _G
    var err = { ("module '%s' not found\n"):format(modname) }
    var loaders = env_package.loaders
    for i in 1 to #loaders do
        var v  = loaders[i](modname)
        var vt = typeof v
        if vt == "function" do
            return setfenv(v, env)
        elif vt == "string" do
            err[#err + 1] = v
        end
    end
    return undef, tconc(err)
end

var gen_import = func(env)
    return func(modname)
        var v = env_package.loaded[modname]
        if v != undef do return v end
        var  loader, err = find_loader(modname, env)
        if not loader do
            raise[2] err
        end
        var ret    = loader(modname)
        var loaded = env_package.loaded
        if ret != undef do
            loaded[modname] = ret
            return ret
        elif loaded[modname] == undef do
            loaded[modname] = true
            return true
        end
        return loaded[modname]
    end
end

var env_structure = {
    ["assert"        ] = true,
    ["ipairs"        ] = true,
    ["math"          ] = true,
    ["pairs"         ] = true,
    ["print"         ] = true,
    ["string"        ] = true,
    ["table"         ] = true,
    ["tonumber"      ] = true,
    ["tostring"      ] = true
}

var ploaded = package.loaded

var eloaded = {}
env_package.loaded = eloaded

var disallow = {
    ["core.externals"] = true, ["core.lua.stream"] = true,
    ["std.jit"] = true, ["std.debug"] = true, ["std.environ"] = true,
    ["std.eval"] = true, ["std.gc"] = true, ["std.package"] = true
}

import std.io as std_io
import std.os as std_os

var std_filtered = {
    ["std.io"] = {
        print = std_io.print,
        write = std_io.write
    },
    ["std.os"] = {
        clock    = std_os.clock,
        date     = std_os.date,
        difftime = std_os.difftime,
        time     = std_os.time
    },
    ["std.table"] = {}
}

var tbl_f = std_filtered["std.table"]

for k, v in pairs(table) do
    tbl_f[k] = v
end

var getmt = table.getmt
tbl_f["getmt"] = func(tbl)
    if typeof tbl == "table" do
        return getmt(tbl)
    end
    return undef
end

var gen_rt = func(env)
    var ret = {}
    for k, v in pairs(table.rawget(_G, "__rt_core")) do
        ret[k] = v
    end
    ret["import"] = gen_import(env)
    return ret
end

var gen_envtable; gen_envtable = func(tbl, env, mod)
    for k, v in pairs(tbl) do
        if v == true do
            env[k] = mod and mod[k] or table.rawget(_G, k)
        elif typeof v == "table" do
            env[k] = {}
            gen_envtable(v, env[k], mod and mod[k] or table.rawget(_G, k))
            eloaded[k] = env[k]
        end
    end
    if not mod do
        env["_G"] = env
        env["__rt_core"] = gen_rt(env)
        eloaded["_G"] = env
        for k, v in pairs(ploaded) do
            if k:match("core%..+") or k:match("octascript%..+")
            or k:match("std%..+") do
                if not disallow[k] do
                    eloaded[k] = std_filtered[k] or v
                else
                    eloaded[k] = false
                end
            end
        end
        return table.setmt(env, table.getmt(_G))
    end
end

/**
    Generates an environment for the mapscript. It's isolated from the outside
    world to some degree, providing some safety against potentially malicious
    code.
*/
M.gen_mapscript_env = func()
    env_package.path = package.path
    return gen_envtable(env_structure, {})
end
var gen_mapscript_env = M.gen_mapscript_env

var consolemap = {
    ["capi"                  ] = "capi",
    ["core.engine.camera"    ] = "camera",
    ["core.engine.cubescript"] = "cubescript",
    ["core.engine.stains"    ] = "stains",
    ["core.engine.edit"      ] = "edit",
    ["core.engine.input"     ] = "input",
    ["core.engine.lights"    ] = "lights",
    ["core.engine.model"     ] = "model",
    ["core.engine.particles" ] = "particles",
    ["core.engine.sound"     ] = "sound",
    ["core.entities.ents"    ] = "ents",
    ["core.entities.svars"   ] = "svars",
    ["core.events.actions"   ] = "actions",
    ["core.events.frame"     ] = "frame",
    ["core.events.input"     ] = "inputev",
    ["core.events.signal"    ] = "signal",
    ["core.events.world"     ] = "world",
    ["core.externals"        ] = "externals",
    ["core.gui.core"         ] = "gui",
    ["core.logger"           ] = "logger",
    ["core.lua.conv"         ] = "conv",
    ["core.lua.geom"         ] = "geom",
    ["core.lua.stream"       ] = "stream",
    ["core.network.msg"      ] = "msg"
}

var consoleenv
var gen_console_env = func()
    if consoleenv do return consoleenv end
    var env = {}
    for k, v in pairs(ploaded) do
        var cmap = consolemap[k]
        if cmap do env[cmap] = v end
    end
    // extra fields
    env["echo"   ] = logger.echo
    env["log"    ] = logger.log
    env["INFO"   ] = logger.INFO
    env["DEBUG"  ] = logger.DEBUG
    env["WARNING"] = logger.WARNING
    env["ERROR"  ] = logger.ERROR
    table.setmt(env, table.setmt({ __index = _G, __newindex = _G },
        { __index = table.getmt(_G) }))
    consoleenv = env
    return env
end

from core.externals import set as ext_set

/** Function: console_lua_run
    An external called when you run Lua code in the console. The console
    has its own special environment featuring most of the core modules as
    globals (so that you don't have to type so much).

    Global mappings:
        - capi - capi
        - core.engine.camera - camera
        - core.engine.cubescript - cubescript
        - core.engine.stains - stains
        - core.engine.edit - edit
        - core.engine.input - input
        - core.engine.lights - lights
        - core.engine.model - model
        - core.engine.particles - particles
        - core.engine.sound - sound
        - core.entities.ents - ents
        - core.entities.svars - svars
        - core.events.actions - actions
        - core.events.frame - frame
        - core.events.input - inputev
        - core.events.signal - signal
        - core.events.world - world
        - core.externals - externals
        - core.gui.core - gui
        - core.logger - logger
        - core.lua.conv - conv
        - core.lua.geom - geom
        - core.lua.stream - stream
        - core.network.msg - msg

    Other global variables:
        - echo, log, INFO, DEBUG, WARNING, ERROR - logger.*
*/
ext_set("console_lua_run", func(str)
    var  ret, err = loadstring(str, "=console")
    if not ret do return err end
    ret, err = try (setfenv(ret, gen_console_env()))()
    if not ret do return err end
    return undef
end)

ext_set("mapscript_run", func(fname)
    var fs, err = stream.open(fname)
    if not fs do raise[2] err end
    var f, err = loadstring(fs:read("*a"), "@" ~ fname)
    fs:close()
    if not f do raise[2] err end
    setfenv(f, gen_mapscript_env())()
end)

ext_set("mapscript_verify", func(fn)
    var f, err = loadfile(fn)
    if not f do
        logger.log(logger.ERROR, "Compilation failed: " ~ err)
        return false
    end
    return true
end)

return M
