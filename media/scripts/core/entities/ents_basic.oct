/**<
    A basic entity set (extends over the base entity).

    Author:
        q66 <quaker66@gmail.com>

    License:
        See COPYING.txt.
*/

import std.ffi
import capi
import core.logger as logging
var log = logging.log
var DEBUG = logging.DEBUG

import core.engine.camera
import core.engine.sound
import core.engine.model
import core.events.frame
import core.events.actions
import core.events.signal
import core.entities.svars
import core.entities.ents
import core.network.msg
import core.engine.cubescript as cs

from std.conv import hex_to_rgb as hextorgb

var var_get = cs.var_get

from core.externals import set as set_external

var Entity = ents.Entity
var ent_get = ents.get

from std.conv import tonumber
from std.math import abs, min, max, clamp
from std.table import concat as tconc, map, len

var connect, emit = signal.connect, signal.emit

from std.util import assert

var set_attachments = capi.set_attachments

// physics state flags
var MASK_MAT = 0x3
var FLAG_WATER = 1 << 0
var FLAG_LAVA  = 2 << 0
var MASK_LIQUID = 0xC
var FLAG_ABOVELIQUID = 1 << 2
var FLAG_BELOWLIQUID = 2 << 2
var MASK_GROUND = 0x30
var FLAG_ABOVEGROUND = 1 << 4
var FLAG_BELOWGROUND = 2 << 4

var animctl = model.anim_control
var anims = model.anims

var anim_dirs, anim_jump, anim_run
@[not server] do
    anim_dirs = {
        anims.run_SE, anims.run_S, anims.run_SW,
        anims.run_E,  0,           anims.run_W,
        anims.run_NE, anims.run_N, anims.run_NW
    }

    anim_jump = {
        [anims.jump_N] = true, [anims.jump_NE] = true, [anims.jump_NW] = true,
        [anims.jump_S] = true, [anims.jump_SE] = true, [anims.jump_SW] = true,
        [anims.jump_E] = true, [anims.jump_W ] = true
    }

    anim_run = {
        [anims.run_N] = true, [anims.run_NE] = true, [anims.run_NW] = true,
        [anims.run_S] = true, [anims.run_SE] = true, [anims.run_SW] = true,
        [anims.run_E] = true, [anims.run_W ] = true
    }
end

var mrender = @[not server,model.render]

/// Module: ents
var M = ents

/**
    Represents the base prototype for any character (NPC, player etc.). Players
    use the $Player entity prototype that inherits from this one.
    Inherited property model_name defaults to "player".

    This entity prototype defines several more properties that do not belong to
    any state variable. These mostly correspond to client_state == {{$State}}.*.
    More will be defined later as needed.

    Non-svar properties:
        - ping - the client ping.
        - plag - the client plag.
        - editing - client_state == EDITING.
        - lagged - client_state == LAGGED.

    Properties:
        - animation [{{$svars.Integer}}] - the entity's current animation.
        - start_time [{{$svars.StateInteger}}] - an internal property used for
          animation timing.
        - model_name [{{$svars.StateString}}] - name of the model associated
          with this entity.
        - attachments [{{$svars.StateArray}}] - an array of model attachments.
          Those are strings in format "tagname,attachmentname".
        - character_name [{{$svars.StateString}}] - name of the character.
        - facing_speed [{{$svars.StateInteger}}] - how fast can the character
          change facing (yaw/pitch) in degrees per second. Defaults to 120.
        - movement_speed [{{$svars.StateFloat}}] - how fast the character can
          move. Defaults to 50.
        - yaw [{{$svars.StateFloat}}] - the current character yaw in degrees.
        - pitch [{{$svars.StateFloat}}] - the current character pitch in
          degrees.
        - roll [{{$svars.StateFloat}}] - the current character roll in
          degrees.
        - move [{{$svars.StateInteger}}] - -1 when moving backwards, 0 when
          not moving, 1 when forward.
        - strafe [{{$svars.StateInteger}}] - -1 when strafing left, 0 when not
          strafing, 1 when right.
        - yawing [{{$svars.StateInteger}}] - -1 when turning left, 1 when
          right, 0 when not at all.
        - pitching [{{$svars.StateInteger}}] - -1 when looking down, 1 when
          up, 0 when not.
        - crouching [{{$svars.StateInteger}}] - -1 when crouching down, 1
          when up, 0 when not.
        - jumping [{{$svars.StateBoolean}}] - true when the character has
          jumped, false otherwise.
        - position [{{$svars.StateVec3}}] - the current position. Defaults to
          { 512, 512, 550 }.
        - velocity [{{$svars.StateVec3}}] - the current velocity.
        - falling [{{$svars.StateVec3}}] - the character's gravity falling.
        - radius [{{$svars.StateFloat}}] - the character's bounding box
          radius. Defaults to 4.1.
        - above_eye [{{$svars.StateFloat}}] - the height of the character
          above its eyes. Defaults to 2.0.
        - eye_height [{{$svars.StateFloat}}] - the distance from the ground to
          the eye position. Defaults to 18.0.
        - max_height [{{$svars.StateFloat}}] - the maximum distance from the
          ground to the eye position. Defaults to 18.0. Used when crouching.
        - crouch_height [{{$svars.StateFloat}}] - the fraction of max_height
          to use when crouched, defaults to 0.75.
        - crouch_speed [{{$svars.StateFloat}}] - the fraction of regular
          movement speed to use while crouching, defaults to 0.4.
        - crouch_time [{{$svars.StateInteger}}] - the time in milliseconds
          spent to crouch, adjust to change the speed.
        - jump_velocity [{{$svars.StateFloat}}] - the vertical velocity to
          apply when jumping, defaults to 125.
        - gravity [{{$svars.StateFloat}}] - a custom character gravity to
          override the global defaults. By default it's -1, which means the
          character will use the global gravity.
        - blocked [{{$svars.StateBoolean}}] - true when the character is
          currently blocked from moving. Floor is not considered an obstacle.
        - can_move [{{$svars.StateBoolean}}] - when false, the character can't
          move. Defaults to true.
        - map_defined_position_data [{{$svars.StateInteger}}] - position
          protocol data specific to the current map, see fpsent (TODO: make
          unsigned).
        - client_state [{{$svars.StateInteger}}] - see $State.
        - physical_state [{{$svars.StateInteger}}] - see $PhysicalState.
        - in_liquid [{{$svars.StateInteger}}] - either 0 (in the air) or the
          liquid material id (water, lava).
        - time_in_air [{{$svars.StateInteger}}] - time in milliseconds spent
          in the air (TODO: unsigned).
*/
M.Character = Entity:clone {
    name = "Character",

    // so that it isn't nonsauer
    sauer_type = -1,

    /**
        Defines the "client states". 0 is ALIVE, 1 is DEAD, 2 is SPAWNING,
        3 is LAGGED, 4 is EDITING, 5 is SPECTATOR.
    */
    State = {:
        ALIVE = 0, DEAD = 1, SPAWNING = 2, LAGGED = 3, EDITING = 4,
        SPECTATOR = 5
    :},

    /**
        Defines the "physical states". 0 is FLOATING, 1 is FALLING,
        2 is SLIDING, 3 is SLOPING, 4 is ON_FLOOR, 5 is STEPPING_UP,
        6 is STEPPING_DOWN, 7 is BOUNCING.
    */
    PhysicalState = {:
        FLOATING = 0, FALLING = 1, SLIDING = 2, SLOPING = 3,
        ON_FLOOR = 4, STEPPING_UP = 5, STEPPING_DOWN = 6, BOUNCING = 7
    :},

    __properties = {
        animation = svars.StateInteger {
            setter = capi.set_animation, client_set = true
        },
        start_time  = svars.StateInteger { getter = capi.get_start_time },
        model_name  = svars.StateString  { setter = capi.set_model_name },
        attachments = svars.StateArray   {
            setter = func(self, val)
                var arr = ffi.new("const char *[?]", len(val) + 1)
                for i in 1 to len(val) do arr[i - 1] = val[i] end
                set_attachments(self, arr)
            end
        },

        character_name = svars.StateString(),
        facing_speed   = svars.StateInteger(),

        movement_speed = svars.StateFloat {
            getter = capi.get_maxspeed, setter = capi.set_maxspeed
        },
        yaw = svars.StateFloat {
            getter = capi.get_yaw, setter = capi.set_yaw,
            custom_sync = true
        },
        pitch = svars.StateFloat {
            getter = capi.get_pitch, setter = capi.set_pitch,
            custom_sync = true
        },
        roll = svars.StateFloat {
            getter = capi.get_roll, setter = capi.set_roll,
            custom_sync = true
        },
        move = svars.StateInteger {
            getter = capi.get_move, setter = capi.set_move,
            custom_sync = true, gui_name = false
        },
        strafe = svars.StateInteger {
            getter = capi.get_strafe, setter = capi.set_strafe,
            custom_sync = true, gui_name = false
        },
        yawing = svars.StateInteger {
            getter = capi.get_yawing, setter = capi.set_yawing,
            custom_sync = true, gui_name = false
        },
        pitching = svars.StateInteger {
            getter = capi.get_pitching, setter = capi.set_pitching,
            custom_sync = true, gui_name = false
        },
        crouching = svars.StateInteger {
            getter = capi.get_crouching, setter = capi.set_crouching,
            custom_sync = true, gui_name = false
        },
        jumping = svars.StateBoolean {
            getter = capi.get_jumping, setter = capi.set_jumping,
            custom_sync = true, gui_name = false
        },
        position = svars.StateVec3 {
            getter = capi.get_dynent_position,
            setter = capi.set_dynent_position,
            custom_sync = true
        },
        velocity = svars.StateVec3 {
            getter = capi.get_dynent_velocity,
            setter = capi.set_dynent_velocity,
            custom_sync = true
        },
        falling = svars.StateVec3 {
            getter = capi.get_dynent_falling,
            setter = capi.set_dynent_falling,
            custom_sync = true, gui_name = false
        },
        radius = svars.StateFloat {
            getter = capi.get_radius, setter = capi.set_radius
        },
        above_eye = svars.StateFloat {
            getter = capi.get_aboveeye, setter = capi.set_aboveeye
        },
        eye_height = svars.StateFloat {
            getter = capi.get_eyeheight, setter = capi.set_eyeheight
        },
        max_height = svars.StateFloat {
            getter = capi.get_maxheight, setter = capi.set_maxheight
        },
        crouch_height = svars.StateFloat {
            getter = capi.get_crouchheight, setter = capi.set_crouchheight
        },
        crouch_speed = svars.StateFloat {
            getter = capi.get_crouchspeed, setter = capi.set_crouchspeed
        },
        crouch_time = svars.StateInteger {
            getter = capi.get_crouchtime, setter = capi.set_crouchtime
        },
        jump_velocity = svars.StateFloat {
            getter = capi.get_jumpvel, setter = capi.set_jumpvel
        },
        gravity = svars.StateFloat {
            getter = capi.get_gravity, setter = capi.set_gravity
        },
        blocked = svars.StateBoolean {
            getter = capi.get_blocked, setter = capi.set_blocked,
            gui_name = false
        },
        can_move = svars.StateBoolean {
            setter = capi.set_can_move, client_set = true
        },
        map_defined_position_data = svars.StateInteger {
            getter = capi.get_mapdefinedposdata,
            setter = capi.set_mapdefinedposdata,
            custom_sync = true, gui_name = false
        },
        client_state = svars.StateInteger {
            getter = capi.get_clientstate, setter = capi.set_clientstate,
            custom_sync = true, gui_name = false
        },
        physical_state = svars.StateInteger {
            getter = capi.get_physstate, setter = capi.set_physstate,
            custom_sync = true, gui_name = false
        },
        in_liquid = svars.StateInteger {
            getter = capi.get_inwater, setter = capi.set_inwater,
            custom_sync = true, gui_name = false
        },
        time_in_air = svars.StateInteger {
            getter = capi.get_timeinair, setter = capi.set_timeinair,
            custom_sync = true, gui_name = false
        },

        physics_trigger = svars.StateInteger { gui_name = false },

        jumping_sound = svars.StateString(),
        landing_sound = svars.StateString()
    },

    /**
        A handler called when the character is about to jump. By default sets
        `jumping` to value of its argument.

        Arguments:
            - down - whether the jump key is down.
    */
    jump = func(self, down)
        self:set_attr("jumping", down)
    end,

    /** Function: crouch
        A handler called when the character is about to crouch. By default
        checks if `down` is true and if it is, sets `crouching` to -1,
        otherwise sets `crouching` to `abs(crouching)`.

        Arguments:
            - down - whether the crouch key is down.
    */
    crouch = func(self, down)
        if down do
            self:set_attr("crouching", -1)
        else
            self:set_attr("crouching", abs(self:get_attr("crouching")))
        end
    end,

    get_plag = func(self) return capi.get_plag(self.uid) end,
    get_ping = func(self) return capi.get_ping(self.uid) end,
    get_editing = func(self) return self:get_attr("client_state") == 4 end,
    get_lagged = func(self) return self:get_attr("client_state") == 3 end,

    __init_svars = @[server,func(self, kwargs)
        Entity.__init_svars(self, kwargs)

        self:set_attr("model_name", "")
        self:set_attr("attachments", {})
        self:set_attr("animation", 3 | (1 << 9))

        self.cn = kwargs and kwargs.cn or -1
        self:set_attr("character_name", "none")
        self:set_attr("model_name", "player")
        self:set_attr("eye_height", 18.0)
        self:set_attr("max_height", 18.0)
        self:set_attr("crouch_height", 0.75)
        self:set_attr("crouch_speed", 0.4)
        self:set_attr("crouch_time", 200)
        self:set_attr("jump_velocity", 125)
        self:set_attr("gravity", -1)
        self:set_attr("above_eye", 2.0)
        self:set_attr("movement_speed", 100.0)
        self:set_attr("facing_speed", 120)
        self:set_attr("position", { 512, 512, 550 })
        self:set_attr("radius", 4.1)
        self:set_attr("can_move", true)

        self:set_attr("physics_trigger", 0)
        self:set_attr("jumping_sound", "gk/jump2.ogg")
        self:set_attr("landing_sound", "olpc/AdamKeshen/kik.wav")
    end],

    __activate = @[server,func(self, kwargs)
        self.cn = kwargs and kwargs.cn or -1
        assert(self.cn >= 0)
        capi.setup_character(self.uid, self.cn)

        Entity.__activate(self, kwargs)

        self:set_attr("model_name", self:get_attr("model_name"))

        self:flush_queued_svar_changes()
    end,func(self, kwargs)
        Entity.__activate(self, kwargs)

        self.cn = kwargs and kwargs.cn or -1
        capi.setup_character(self.uid, self.cn)

        self.render_args_timestamp = -1

        // see world.oct for field meanings
        connect(self, "physics_trigger,changed", func(self, val)
            if val == 0 do return end
            self:set_attr("physics_trigger", 0)

            var pos = (self != ents.get_player())
                and self:get_attr("position") or undef

            var lst = val & MASK_LIQUID
            if lst == FLAG_ABOVELIQUID do
                if (val & MASK_MAT) != FLAG_LAVA do
                    sound.play("yo_frankie/amb_waterdrip_2.wav", pos)
                end
            elif lst == FLAG_BELOWLIQUID do
                sound.play((val & MASK_MAT) == FLAG_LAVA
                    and "yo_frankie/DeathFlash.wav"
                    or "yo_frankie/watersplash2.wav", pos)
            end

            var gst = val & MASK_GROUND
            if gst == FLAG_ABOVEGROUND do
                sound.play(self:get_attr("jumping_sound"), pos)
            elif gst == FLAG_BELOWGROUND do
                sound.play(self:get_attr("landing_sound"), pos)
            end
        end)
    end],

    __deactivate = func(self)
        capi.destroy_character(self.cn)
        Entity.__deactivate(self)
    end,

    /**
        Decides the base time to use for animation rendering of the character.
        By default simply returns `start_time`.
    */
    decide_base_time = func(self, anim)
        return self:get_attr("start_time")
    end,

    /** Function: __render
        Clientside and run per frame. It renders the character model. Decides
        all the parameters, including animation etc.

        When rendering HUD, the member `hud_model_offset` (vec3) is used to
        offset the HUD model (if available).

        There is one additional argument, fpsshadow - it's true if we're about
        to render a first person shadow (can be true only when needhud is true
        and hudpass is false).

        Arguments:
            - hudpass - a bool, true if we're rendering the HUD pass (whether
              we're rendering a HUD model right now).
            - needhud - true if we're in first person mode.
            - fpsshadow - true if we enabled a FPS player shadow.
    */
    __render = @[not server,func(self, hudpass, needhud, fpsshadow)
        if not self.initialized do return end
        if not hudpass and needhud and not fpsshadow do return end

        var state = self:get_attr("client_state")
        // spawning or spectator
        if state == 5 or state == 2 do return end
        // editing
        if not hudpass and needhud and state == 4 do return end
        var mdn = (hudpass and needhud)
            and self:get_attr("hud_model_name")
            or  self:get_attr("model_name")

        if mdn == "" do return end

        var yaw, pitch, roll = self:get_attr("yaw"),
            self:get_attr("pitch"),
            self:get_attr("roll")
        var o = self:get_attr("position"):copy()

        if hudpass and needhud and self.hud_model_offset do
            o:add(self.hud_model_offset)
        end

        var pstate = self:get_attr("physical_state")
        var iw = self:get_attr("in_liquid")
        var mv, sf = self:get_attr("move"), self:get_attr("strafe")

        var vel, fall = self:get_attr("velocity"):copy(),
            self:get_attr("falling"):copy()
        var tia = self:get_attr("time_in_air")

        var cr = self:get_attr("crouching")

        var anim = self:decide_animation(state, pstate, mv,
            sf, cr, vel, fall, iw, tia)

        var bt = self:decide_base_time(anim)

        var flags = self:get_render_flags(hudpass, needhud)

        mrender(self, mdn, anim, o, yaw, pitch, roll, flags, bt)
    end],

    /** Function: get_render_flags
        Returns the rendering flags used when rendering the character. By
        default, it enables some occlusion stuff. Override as needed.
        Called from $__render. Clientside.

        Arguments:
            - hudpass, needhud - see $__render.
    */
    get_render_flags = @[not server,func(self, hudpass, needhud)
        var flags
        if self != ents.get_player() do
            flags = model.render_flags.CULL_VFC
                | model.render_flags.CULL_OCCLUDED
                | model.render_flags.CULL_QUERY
        else
            flags = model.render_flags.FULLBRIGHT
        end
        if needhud do
            if hudpass do
                flags |= model.render_flags.NOBATCH
            else
                flags |= model.render_flags.ONLY_SHADOW
            end
        end
        return flags
    end],

    /** Function: get_animation
        Returns the base "action animation" used by $decide_animation. By
        default simply return the `animation` attribute.
    */
    get_animation = @[not server,func(self)
        return self:get_attr("animation")
    end],

    /** Function: decide_animation
        Decides the current animation for the character. Starts with
        $get_animation, then adjusts it to take things like moving,
        strafing, swimming etc into account. Returns the animation
        (an array) and animation flags (by default 0).

        Arguments:
            - state - client state (see $State).
            - pstate - physical state (see $PhysicalState).
            - move, strafe, crouching, vel, falling, unwater, tinair - see
              the appropriate state variables.
    */
    decide_animation = @[not server,func(self, state, pstate, move,
    strafe, crouching, vel, falling, inwater, tinair)
        var anim = self:get_animation()

        var mask = anims.INDEX | anims.DIR
        var panim, sanim = anim & mask, (anim >> anims.SECONDARY) & mask

        // editing or spectator
        if state == 4 or state == 5 do
            panim = anims.edit | animctl.LOOP
        // lagged
        elif state == 3 do
            panim = anims.lag | animctl.LOOP
        else
            // in water and floating or falling
            if inwater != 0 and pstate <= 1 do
                sanim = (((move or strafe) or ((vel.z + falling.z) > 0))
                    and anims.swim or anims.sink) | animctl.LOOP
            // moving or strafing
            else
                var dir = anim_dirs[(move + 1) * 3 + strafe + 2]
                // jumping anim
                if tinair > 100 do
                    sanim = ((dir != 0) and (dir + anims.jump_N - anims.run_N)
                        or anims.jump) | animctl.END
                elif dir != 0 do
                    sanim = dir | animctl.LOOP
                end
            end

            if crouching != 0 do
                var v = sanim & anims.INDEX
                if v == anims.idle do
                    sanim = sanim & ~anims.INDEX
                    sanim = sanim | anims.crouch
                elif v == anims.jump do
                    sanim = sanim & ~anims.INDEX
                    sanim = sanim | anims.crouch_jump
                elif v == anims.swim do
                    sanim = sanim & ~anims.INDEX
                    sanim = sanim | anims.crouch_swim
                elif v == anims.sink do
                    sanim = sanim & ~anims.INDEX
                    sanim = sanim | anims.crouch_sink
                elif v == 0 do
                    sanim = anims.crouch | animctl.LOOP
                elif anim_run[v] do
                    sanim = sanim + anims.crouch_N - anims.run_N
                elif anim_jump[v] do
                    sanim = sanim + anims.crouch_jump_N - anims.jump_N
                end
            end

            if (panim & anims.INDEX) == anims.idle and
               (sanim & anims.INDEX) != 0 do
                panim = sanim
            end
        end

        if (sanim & anims.INDEX) == 0 do
            sanim = anims.idle | animctl.LOOP
        end
        return panim | (sanim << anims.SECONDARY)
    end],

    /**
        Gets the center position of a character, something like gravity center
        (approximate). Useful for e.g. bots (better to aim at this position,
        the actual `position` is feet position). Override if you need this
        non-standard. By default it's 0.75 * eye_height above feet.
    */
    get_center = func(self)
        var r = self:get_attr("position"):copy()
        r.z = r.z + self:get_attr("eye_height") * 0.75
        return r
    end,

    /**
        Given an origin position (e.g. from an attachment tag), this method
        is supposed to fix it so that it corresponds to where player actually
        targeted from. By default just returns origin.
    */
    get_targeting_origin = func(self, origin)
        return origin
    end,

    /**
        Sets the `animation` property locally, without notifying the other
        side. Useful when allowing actions to animate the entity (as we mostly
        don't need the changes to reflect elsewhere).
    */
    set_local_animation = func(self, anim)
        capi.set_animation(self.uid, anim)
        self.svar_values["animation"] = anim
    end,

    /**
        Sets the `model_name` property locally, without notifying the other
        side.
    */
    set_local_model_name = func(self, mname)
        capi.set_model_name(self.uid, mname)
        self.svar_values["model_name"] = mname
    end
}
var Character = M.Character

/** Function: physics_collide_client
    An external called when two clients collide. Takes unique ids of both
    entities. By default emits the "collision" signal on both clients, passing
    the other one as an argument. The client we're testing collisions against
    gets the first emit.
*/
set_external("physics_collide_client", func(cl1, cl2, dx, dy, dz)
    cl1, cl2 = ent_get(cl1), ent_get(cl2)
    emit(cl1, "collision", cl2, dx, dy, dz)
    emit(cl2, "collision", cl1, dx, dy, dz)
end)

set_external("entity_set_local_animation", func(uid, anim)
    ent_get(uid):set_local_animation(anim)
end)

/**
    The default entity prototype for player. Inherits from $Character. Adds
    two new properties.

    Properties:
        - can_edit [false] - if player can edit, it's true (private edit mode).
        - hud_model_name [""] - the first person model to use for the player.
*/
M.Player = Character:clone {
    name = "Player",

    __properties = {
        can_edit = svars.StateBoolean(),
        hud_model_name = svars.StateString()
    },

    __init_svars = @[server,func(self, kwargs)
        Character.__init_svars(self, kwargs)

        self:set_attr("can_edit", false)
        self:set_attr("hud_model_name", "")
    end]
}

ents.register_prototype(Character)
ents.register_prototype(M.Player)

var c_get_attr = capi.get_attr
var c_set_attr = capi.set_attr

var gen_attr = func(i, name)
    i = i - 1
    return svars.StateInteger {
        getter = func(ent)      return c_get_attr(ent, i)      end,
        setter = func(ent, val) return c_set_attr(ent, i, val) end,
        gui_name = name, alt_name = name
    }
end

/**
    A base for any static entity. Inherits from $Entity. Unlike
    dynamic entities (such as $Character$), static entities usually don't
    invoke their `__run` method per frame. To re-enable that, set the
    `__per_frame` member to true (false by default for efficiency).

    Static entities are persistent by default, so they set the `persistent`
    inherited property to true.

    This entity prototype is never registered, the inherited ones are.

    Properties:
        position [{{$svars.StateVec3}}] - the entity position.
*/
M.StaticEntity = Entity:clone {
    name = "StaticEntity",

    /// The icon that'll be displayed in edit mode.
    __edit_icon = "media/interface/icon/edit_generic",

    __per_frame = false,
    sauer_type = 0,
    attr_num   = 0,

    __properties = {
        position = svars.StateVec3 {
            getter = capi.get_extent_position,
            setter = capi.set_extent_position
        }
    },

    __init_svars = func(self, kwargs)
        @[debug] log(DEBUG, "StaticEntity.init")

        kwargs = kwargs or {}
        kwargs.persistent = true

        Entity.__init_svars(self, kwargs)
        if not kwargs.position do
            self:set_attr("position", { 511, 512, 513 })
        else
            self:set_attr("position", {
                tonumber(kwargs.position.x),
                tonumber(kwargs.position.y),
                tonumber(kwargs.position.z)
            })
        end

        @[debug] log(DEBUG, "StaticEntity.init complete")
    end,

    __activate = @[server,func(self, kwargs)
        kwargs = kwargs or {}

        @[debug] log(DEBUG, "StaticEntity.__activate")
        Entity.__activate(self, kwargs)

        @[debug] log(DEBUG, "StaticEntity: extent setup")
        capi.setup_extent(self.uid, self.sauer_type)

        @[debug] log(DEBUG, "StaticEntity: flush")
        self:flush_queued_svar_changes()

        self:set_attr("position", self:get_attr("position"))
        for i in 1 to self.attr_num do
            var an = "attr" ~ i
            self:set_attr(an, self:get_attr(an))
        end
    end,func(self, kwargs)
        capi.setup_extent(self.uid, self.sauer_type)
        return Entity.__activate(self, kwargs)
    end],

    __deactivate = func(self)
        capi.destroy_extent(self.uid)
        return Entity.__deactivate(self)
    end,

    send_notification_full = @[server,func(self, cn)
        var acn = msg.ALL_CLIENTS
        cn = cn or acn

        var cns = (cn == acn) and ents.get_players():map(\p -> p.cn) or [ cn ]

        var uid = self.uid
        @[debug] log(DEBUG, "StaticEntity.send_notification_full: "
            ~ cn ~ ", " ~ uid)

        var scn, sname = self.cn, self.name
        for i, n in cns:each() do
            msg.send(n, capi.extent_notification_complete, uid, sname,
                self:build_sdata({ target_cn = n, compressed = true }))
        end

        @[debug] log(DEBUG, "StaticEntity.send_notification_full: done")
    end],

    /**
        See {{$Character.get_center}}. By default this is the entity position.
        May be overloaded for other entity types.
    */
    get_center = func(self)
        return self:get_attr("position"):copy()
    end,

    /**
        Returns the color of the entity icon in edit mode. If an invalid
        value is returned, it defaults to 255, 255, 255 (white). This is
        useful for e.g. light entity that is colored.
    */
    __get_edit_color = func(self)
        return 255, 255, 255
    end,

    /**
        Returns any piece of information displayed in in the edit HUD in
        addition to the entity name. Overload for different entity types.
    */
    __get_edit_info = func(self)
        return undef
    end,

    /**
        Returns the currently attached entity. Useful mainly for spotlights.
        This refers to the "internally attached" entity that the core engine
        works with.
    */
    get_attached_entity = func(self)
        return capi.get_attached_entity(self.uid)
    end,

    /**
        Returns the height above the floor to use when dropping the entity
        to the floor. By default returns 4, may be useful to overload (for
        say, mapmodels).
    */
    get_edit_drop_height = func(self)
        return 4
    end
}
var StaticEntity = M.StaticEntity

/** Function: entity_get_edit_info
    An external. Returns `ent.__edit_icon`,
    `ent:{{$StaticEntity.__get_edit_color|__get_edit_color}}()` where `ent`
    is the entity with unique id `uid`.
*/
set_external("entity_get_edit_icon_info", func(uid)
    var ent = ent_get(uid)
    return ent.__edit_icon, ent:__get_edit_color()
end)

/** Function: entity_get_edit_info
    An external. Returns the entity name and the return value of
    {{$StaticEntity.__get_edit_info}}.
*/
set_external("entity_get_edit_info", func(uid)
    var ent = ent_get(uid)
    return ent.name, ent:__get_edit_info()
end)

/** Function: entity_get_edit_drop_height
    An external, see {{$StaticEntity.get_edit_drop_height}}. Takes the uid.
*/
set_external("entity_get_edit_drop_height", func(ent)
    return ent_get(ent):get_edit_drop_height()
end)

/**
    A generic marker without orientation. It doesn't have any default
    additional properties.
*/
M.Marker = StaticEntity:clone {
    name = "Marker",

    __edit_icon = "media/interface/icon/edit_marker",

    sauer_type = 1,

    /// Places the given entity on this marker's position.
    place_entity = func(self, ent)
        ent:set_attr("position", self:get_attr("position"))
    end
}
var Marker = M.Marker

/**
    A generic (oriented) marker with a wide variety of uses. Can be used as
    a base for various position markers (e.g. playerstarts).

    An example of world marker usage is a cutscene system. Different marker
    types inherited from this one can represent different nodes.

    Properties:
        - attr1 - aka "yaw".
        - attr2 - aka "pitch".
*/
M.OrientedMarker = StaticEntity:clone {
    name = "OrientedMarker",

    __edit_icon = "media/interface/icon/edit_marker",

    sauer_type = 2,
    attr_num   = 2,

    __properties = {
        attr1 = gen_attr(1, "yaw"),
        attr2 = gen_attr(2, "pitch")
    },

    __init_svars = func(self, kwargs, nd)
        StaticEntity.__init_svars(self, kwargs, nd)
        self:set_attr("yaw", 0, nd[1])
        self:set_attr("pitch", 0, nd[2])
    end,

    /// Places the given entity on this marker's position, using yaw and pitch.
    place_entity = func(self, ent)
        ent:set_attr("position", self:get_attr("position"))
        ent:set_attr("yaw", self:get_attr("yaw"))
        ent:set_attr("pitch", self:get_attr("pitch"))
    end,

    __get_edit_info = func(self)
        return ("yaw :\f2 %d \f7| pitch :\f2 %d"):format(self:get_attr("yaw"),
            self:get_attr("pitch"))
    end
}
var OrientedMarker = M.OrientedMarker

from std.table import setmt

var lightflags = setmt({
    [0] = "dynamic (0)",
    [1] = "none (1)",
    [2] = "static (2)"
}, {
    __index = func(self, i)
        return ("invalid (%d)"):format(i)
    end
})

/**
    A regular point light. In the extension library there are special light
    entity types that are e.g. triggered, flickering and so on. When providing
    properties as extra arguments to newent, you can specify red, green, blue,
    radius and shadow in that order.

    Properties:
        - attr1 - light radius. (0 to N, alias "radius", default 100 - 0 or
          lower means the light is off)
        - attr2 - red value (can be any range, even negative - typical values
          are 0 to 255, negative values make a negative light, alias "red",
          default 128)
        - attr3 - green value (alias "green", default 128)
        - attr4 - blue value (alias "blue", default 128)
        - attr5 - shadow type, 0 means dnyamic, 1 disabled, 2 static (default 0).
*/
M.Light = StaticEntity:clone {
    name = "Light",

    __edit_icon = "media/interface/icon/edit_light",

    sauer_type = 3,
    attr_num   = 5,

    __properties = {
        attr1 = gen_attr(1, "radius"),
        attr2 = gen_attr(2, "red"),
        attr3 = gen_attr(3, "green"),
        attr4 = gen_attr(4, "blue"),
        attr5 = gen_attr(5, "shadow")
    },

    __init_svars = func(self, kwargs, nd)
        StaticEntity.__init_svars(self, kwargs, nd)
        self:set_attr("red", 128, nd[1])
        self:set_attr("green", 128, nd[2])
        self:set_attr("blue", 128, nd[3])
        self:set_attr("radius", 100, nd[4])
        self:set_attr("shadow", 0, nd[5])
    end,

    __get_edit_color = func(self)
        return self:get_attr("red"), self:get_attr("green"),
            self:get_attr("blue")
    end,

    __get_edit_info = func(self)
        return ("red :\f2 %d \f7| green :\f2 %d \f7| blue :\f2 %d\n\f7"
            ~ "radius :\f2 %d \f7| shadow :\f2 %s"):format(
            self:get_attr("red"), self:get_attr("green"),
            self:get_attr("blue"), self:get_attr("radius"),
            lightflags[self:get_attr("shadow")])
    end
}

/**
    A spot light. It's attached to the nearest $Light. Properties such as
    color are retrieved from the attached light entity.

    Properties:
        - attr1 - alias "radius", defaults to 90, in degrees (90 is a full
          hemisphere, 0 is a line)
*/
M.SpotLight = StaticEntity:clone {
    name = "SpotLight",

    __edit_icon = "media/interface/icon/edit_spotlight",

    sauer_type = 4,
    attr_num   = 1,

    __properties = {
        attr1 = gen_attr(1, "radius")
    },

    __init_svars = func(self, kwargs, nd)
        StaticEntity.__init_svars(self, kwargs, nd)
        self:set_attr("radius", 90, nd[1])
    end,

    __get_edit_color = func(self)
        var ent = self:get_attached_entity()
        if not ent do return 255, 255, 255 end
        return ent:get_attr("red"), ent:get_attr("green"), ent:get_attr("blue")
    end,

    __get_edit_info = func(self)
        return ("radius :\f2 %d"):format(self:get_attr("radius"))
    end
}

/**
    An environment map entity prototype. Things reflecting on their surface using
    environment maps can generate their envmap from the nearest envmap entity
    instead of using skybox and reflect geometry that way (statically). You
    can specify the radius as an extra argument to newent.

    Properties:
        - attr1 - alias "radius", the distance it'll still have effect in,
          defaults to 128.
*/
M.Envmap = StaticEntity:clone {
    name = "Envmap",

    __edit_icon = "media/interface/icon/edit_envmap",

    sauer_type = 5,
    attr_num   = 1,

    __properties = {
        attr1 = gen_attr(1, "radius")
    },

    __init_svars = func(self, kwargs, nd)
        StaticEntity.__init_svars(self, kwargs, nd)
        self:set_attr("radius", 128, nd[1])
    end,

    __get_edit_info = func(self)
        return ("radius :\f2 %d"):format(self:get_attr("radius"))
    end
}

/**
    A sound effect prototype. You can use this to make your own sound effect
    types.

    Properties:
        - attr1 - the sound radius (alias "radius", default 100)
        - attr2 - the sound size, if this is 0, the sound is a point source,
          otherwise the sound volume will always be max until the distance
          specified by this property and do it'll start fading off
          (alias "size", default 0).
*/
M.SoundEffect = StaticEntity:clone {
    name = "Sound",

    __edit_icon = "media/interface/icon/edit_sound",

    sauer_type = 6,
    attr_num   = 2,

    __properties = {
        attr1 = gen_attr(1, "radius"),
        attr2 = gen_attr(2, "size")
    },

    __init_svars = func(self, kwargs, nd)
        StaticEntity.__init_svars(self, kwargs, nd)
        self:set_attr("radius", 100, nd[1])
        self:set_attr("size", 0, nd[2])
    end,

    __activate = @[not server,func(self, ...)
        StaticEntity.__activate(self, ...)
        connect(self, "radius,changed", self.sound_stop)
        connect(self, "size,changed", self.sound_stop)
    end],

    /** Stop all sounds currently assigned to the entity. */
    sound_stop = func(self)
        capi.sound_stop_map(self.uid)
    end,

    /** Play a sound on this entity. The last loops parameter is optional. */
    sound_play = func(self, name, volume, loops)
        capi.sound_play_map(self.uid, name, volume, loops or -1)
    end,

    /** Override to play sounds. */
    __play_sound = func(self) end
}

var SoundEffect = M.SoundEffect

/**
    A generic ambient sound entity. Repeats the given sound at the entity
    position. You can specify (in addition to default radius and size) the
    sound name and volume. The extra arguments to newent go as follows:
    sound name, volume, radius, size.

    Properties:
        - volume [{{$svars.StateInteger}}] - the sound volume, from 0 to 100
          (default 100)
        - sound_name [{{$svars.StateString}}] - the  path to the sound in
          media/sound (default "").
*/
M.AmbientSound = SoundEffect:clone {
    name = "AmbientSound",

    __properties = {
        volume = svars.StateInteger(),
        sound_name = svars.StateString()
    },

    __init_svars = func(self, kwargs, nd)
        SoundEffect.__init_svars(self, kwargs, { nd[3], nd[4] })
        self:set_attr("volume", 100, nd[2])
        self:set_attr("sound_name", "", nd[1])
    end,

    __activate = @[not server,func(self, ...)
        SoundEffect.__activate(self, ...)
        connect(self, "sound_name,changed", self.sound_stop)
        connect(self, "volume,changed", self.sound_stop)
    end],

    __get_edit_info = func(self)
        return ("radius :\f2 %d \f7| size :\f2 %d \f7| volume :\f2 %d"
            ~ "\n\f7name :\f2 %s"):format(
            self:get_attr("radius"), self:get_attr("size"),
            self:get_attr("volume"), self:get_attr("sound_name"))
    end,

    __play_sound = func(self)
        self:sound_play(self:get_attr("sound_name"), self:get_attr("volume"))
    end
}

set_external("sound_play_map", func(uid)
    ent_get(uid):__play_sound()
end)

/**
    A particle effect entity prototype. You can derive from this to create
    your own effects, but by default this doesn't draw anything and is
    not registered. It also specifies __emit_particles as a composable
    method.
*/
M.ParticleEffect = StaticEntity:clone {
    name = "ParticleEffect",

    __edit_icon  = "media/interface/icon/edit_particles",
    sauer_type = 7,

    __plugin_methods = { "__emit_particles" },

    /// Returns 0.
    get_edit_drop_height = func(self)
        return 0
    end,

    /// This is what you need to override - draw your particles from here.
    __emit_particles = func(self) end
}

set_external("particle_entity_emit", func(uid)
    ent_get(uid):__emit_particles()
end)

/**
    A model in the world. All attrs default to 0. On mapmodels and all
    entity types derived from mapmodels, the engine emits the `collision`
    signal with the collider entity passed as an argument when collided.
    You can specify the model name, yaw, pitch, roll and scale as extra
    arguments to newent.

    Properties:
        - animation [{{$svars.StateInteger}}] - the mapmodel's current
          animation. See $Character.
        - start_time [{{$svars.StateInteger}}] - an internal property used for
          animation timing.
        - model_name [{{$svars.StateString}}] - name of the model associated
          with this mapmodel.
        - attachments [{{$svars.StateArray}}] - an array of model attachments.
          Those are strings in format "tagname,attachmentname".
        - attr1 - the model yaw, alias "yaw".
        - attr2 - the model pitch, alias "pitch".
        - attr3 - the model roll, alias "roll".
        - attr4 - the model scale, alias "scale".
*/
M.Mapmodel = StaticEntity:clone {
    name = "Mapmodel",

    __edit_icon = "media/interface/icon/edit_mapmodel",

    sauer_type = 8,
    attr_num   = 4,

    __properties = {
        animation = svars.StateInteger {
            setter = capi.set_animation, client_set = true
        },
        start_time  = svars.StateInteger { getter = capi.get_start_time   },
        model_name  = svars.StateString  { setter = capi.set_model_name   },
        attachments = svars.StateArray   {
            setter = func(self, val)
                return set_attachments(self, map(val, func(str)
                    return str:split(",")
                end))
            end
        },

        attr1 = gen_attr(1, "yaw"),
        attr2 = gen_attr(2, "pitch"),
        attr3 = gen_attr(3, "roll"),
        attr4 = gen_attr(4, "scale")
    },

    __init_svars = @[server,func(self, kwargs, nd)
        StaticEntity.__init_svars(self, kwargs, nd)
        self:set_attr("model_name", "", nd[1])
        self:set_attr("yaw", 0, nd[2])
        self:set_attr("pitch", 0, nd[3])
        self:set_attr("roll", 0, nd[4])
        self:set_attr("scale", 0, nd[5])
        self:set_attr("attachments", {})
        self:set_attr("animation", 3 | (1 << 9))
    end],

    __activate = @[server,func(self, kwargs)
        StaticEntity.__activate(self, kwargs)
        self:set_attr("model_name", self:get_attr("model_name"))
    end],

    __get_edit_info = func(self)
        return ("yaw :\f2 %d \f7| pitch :\f2 %d \f7| roll :\f2 %d \f7|"
            ~ " scale :\f2 %d\n\f7name :\f2 %s"):format(
            self:get_attr("yaw"), self:get_attr("pitch"),
            self:get_attr("roll"), self:get_attr("scale"),
            self:get_attr("model_name"))
    end,

    /// Returns 0.
    get_edit_drop_height = func(self)
        return 0
    end,

    /// See {{$Character.set_local_animation}}.
    set_local_animation = Character.set_local_animation,

    /// See {{$Character.set_local_model_name}}.
    set_local_model_name = Character.set_local_model_name
}

/** Function: physics_collide_mapmodel
    An external called when a client collides with a mapmodel. Takes the
    collider entity uid (the client) and the mapmodel entity uid. By default
    emits the `collision` signal on both entities, passing the other one as an
    argument. The mapmodel takes precedence.
*/
set_external("physics_collide_mapmodel", func(collider, entity)
    collider, entity = ent_get(collider), ent_get(entity)
    emit(entity, "collision", collider)
    emit(collider, "collision", entity)
end)

/**
    An entity prototype that emits a `collision` signal on itself when a client
    (player, NPC...) collides with it. You can specify the properties as extra
    arguments to newent.

    Properties:
        - attr1, attr2, attr3 - alias "yaw", "pitch", "roll", all 0.
        - attr4, attr5, attr6 - alias "a", "b", "c" (the dimensions,
          10, 10, 10 by default).
        - attr7 - alias "solid", makes the obstacle solid when not 0 (0
          by default).
*/
M.Obstacle = StaticEntity:clone {
    name = "Obstacle",

    sauer_type = 9,
    attr_num   = 7,

    __properties = {
        attr1 = gen_attr(1, "yaw"),
        attr2 = gen_attr(2, "pitch"),
        attr3 = gen_attr(3, "roll"),
        attr4 = gen_attr(4, "a"),
        attr5 = gen_attr(5, "b"),
        attr6 = gen_attr(6, "c"),
        attr7 = gen_attr(7, "solid")
    },

    __init_svars = func(self, kwargs, nd)
        StaticEntity.__init_svars(self, kwargs, nd)
        self:set_attr("yaw", 0, nd[4])
        self:set_attr("pitch", 0, nd[5])
        self:set_attr("roll", 0, nd[6])
        self:set_attr("a", 10, nd[1])
        self:set_attr("b", 10, nd[2])
        self:set_attr("c", 10, nd[3])
        self:set_attr("solid", 0, nd[7])
    end,

    __get_edit_info = func(self)
        return ("yaw :\f2 %d \f7| pitch :\f2 %d \f7| roll :\f2 %d\n\f7"
            ~ "a :\f2 %d \f7| b :\f2 %d \f7| c :\f2 %d \f7| solid :\f2 %d"):format(
            self:get_attr("yaw"),  self:get_attr("pitch"),
            self:get_attr("roll"), self:get_attr("a"),
            self:get_attr("b"),    self:get_attr("c"), self:get_attr("solid"))
    end,

    /// Returns 0.
    get_edit_drop_height = func(self)
        return 0
    end
}

/**
    A decal entity prototype. It represents a decal that sticks to world geometry.
    Refer to Tesseract documentation for decals. You can specify the properties
    as extra arguments to newent, in slot, size, yaw, pitch, roll order
    (unlike Tesseract, which is slot, yaw, pitch, roll, size).

    Properties:
        - attr1 - alias "slot", the decal slot used.
        - attr2, attr3, attr4 - alias "yaw", "pitch", "roll", 0 by default.
        - atr5 - alias "size", the decal size in cube units.
*/
M.Decal = StaticEntity:clone {
    name = "Decal",

    sauer_type = 10,
    attr_num   = 5,

    __properties = {
        attr1 = gen_attr(1, "slot"),
        attr2 = gen_attr(2, "yaw"),
        attr3 = gen_attr(3, "pitch"),
        attr4 = gen_attr(4, "roll"),
        attr5 = gen_attr(5, "size")
    },

    __init_svars = func(self, kwargs, nd)
        StaticEntity.__init_svars(self, kwargs, nd)
        self:set_attr("slot",  0, nd[1])
        self:set_attr("yaw",   0, nd[3])
        self:set_attr("pitch", 0, nd[4])
        self:set_attr("roll",  0, nd[5])
        self:set_attr("size",  1, nd[2])
    end,

    __get_edit_info = func(self)
        return ("yaw :\f2 %d \f7| pitch :\f2 %d \f7| roll :\f2 %d\n\f7"
            ~ "slot :\f2 %d \f7| size :\f2 %d"):format(
            self:get_attr("yaw"),  self:get_attr("pitch"),
            self:get_attr("roll"), self:get_attr("slot"),
            self:get_attr("size"))
    end,

    /// Returns 0.
    get_edit_drop_height = func(self)
        return 0
    end
}

/** Function: physics_collide_area
    An external called when a client collides with an area. Takes the
    collider entity uid (the client) and the area entity uid. By default emits
    the `collision` signal on both entities, passing the other one as an
    argument. The obstacle takes precedence.
*/
set_external("physics_collide_area", func(collider, entity)
    collider, entity = ent_get(collider), ent_get(entity)
    emit(entity, "collision", collider)
    emit(collider, "collision", entity)
end)

ents.register_prototype(M.Marker)
ents.register_prototype(M.OrientedMarker)
ents.register_prototype(M.Light)
ents.register_prototype(M.SpotLight)
ents.register_prototype(M.Envmap)
ents.register_prototype(M.AmbientSound)
ents.register_prototype(M.Mapmodel)
ents.register_prototype(M.Obstacle)
ents.register_prototype(M.Decal)
