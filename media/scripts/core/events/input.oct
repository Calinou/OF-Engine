/**<
    Registers several input events.

    Author:
        q66 <quaker66@gmail.com>

    License:
        See COPYING.txt.
*/

import capi
import core.network.msg
import core.events.signal

var emit = signal.emit
var ents

/** Function: input_mouse_move
    The default behavior is hardcoded. If the external exists, it takes two
    arguments (yaw and pitch) and should return again yaw and pitch (as two
    return values). Just returning the inputs results in the default behavior,
    so this pretty much works as a filter.
*/
var input_mouse_move

import core.externals as ext
var get_ext, set_ext, unset_ext = ext.get, ext.set, ext.unset

var event_map

@[not server] {
/** Function: input_yaw
    An external triggered on yaw change. By default it sets the "yawing"
    property on the player to "dir".

    Arguments:
        - dir - the yawing direction.
        - down - whether the key was pressed.
*/
set_ext("input_yaw", func(dir, down) {
    if not ents { ents = import core.entities.ents }
    ents::get_player().set_attr("yawing", dir)
})

/** Function: input_pitch
    An external triggered on pitch change. By default it sets the "pitching"
    property on the player to "dir".

    Arguments:
        - dir - the pitching direction.
        - down - whether the key was pressed.
*/
set_ext("input_pitch", func(dir, down) {
    if not ents { ents = import core.entities.ents }
    ents::get_player().set_attr("pitching", dir)
})

/** Function: input_move
    An external triggered during movement. By default it sets the "move"
    property on the player to "dir".

    Arguments:
        - dir - the move direction.
        - down - whether the key was pressed.
*/
set_ext("input_move", func(dir, down) {
    if not ents { ents = import core.entities.ents }
    ents::get_player().set_attr("move", dir)
})

/** Function: input_strafe
    An external triggered during strafing. By default it sets the "strafe"
    property on the player to "dir".

    Arguments:
        - dir - the strafe direction.
        - down - whether the key was pressed.
*/
set_ext("input_strafe", func(dir, down) {
    if not ents { ents = import core.entities.ents }
    ents::get_player().set_attr("strafe", dir)
})

/** Function: input_jump
    An external triggered when the player jumps. By default calls the method
    "jump" on the player, passing "down" as an argument.

    Arguments:
        - down - whether the key was pressed.
*/
set_ext("input_jump", func(down) {
    if not ents { ents = import core.entities.ents }
    ents::get_player().jump(down)
})

/** Function: input_crouch
    An external triggered when the player crouches. By default calls the method
    "crouch" on the player, passing "down" as an argument.

    Arguments:
        - down - whether the key was pressed.
*/
set_ext("input_crouch", func(down) {
    if not ents { ents = import core.entities.ents }
    ents::get_player().crouch(down)
})

/** Function: input_click
    Clientside click input handler. It calls another external,
    $input_click_client, which you can override. If that external doesn't
    return a value that evaluates to true, it sends a click request to the
    server. Do not override this.

    Arguments:
        - btn - the clicked button.
        - down - whether it was pressed.
        - x, y, z - the position of the click in the world.
        - uid - the unique ID of the entity that was clicked
          (if any, undef otherwise).
        - cx, cy - the cursor position.
*/
set_ext("input_click", func(btn, down, x, y, z, uid, cx, cy) {
    if not get_ext("input_click_client")(btn, down, x, y, z, uid, cx, cy) {
        msg::send(capi.do_click, btn, down, x, y, z, uid)
    }
})

/** Function: input_click_client
    Clientside external for user-defined clicks. By default it tries to call
    the click method on the given entity assuming the entity exists and it
    has a method of that name. It takes the same arguments as $input_click
    and by default returns false, which means the above external will
    trigger a server request.
*/
set_ext("input_click_client", func(btn, down, x, y, z, uid, cx, cy) {
    if not ents { ents = import core.entities.ents }
    var ent
    if uid >= 0 { ent = ents::get(uid) }
    if ent and ent.click {
        return ent.click(btn, down, x, y, z, cx, cy)
    }
    return false
})

event_map = {
    "input_yaw"         : true,
    "input_pitch"       : true,
    "input_move"        : true,
    "input_strafe"      : true,
    "input_jump"        : true,
    "input_crouch"      : true,
    "input_click_client": true,
    "input_mouse_move"  : true
}

}

@[server] {
/** Function: input_click_server
    Serverside external for user-defined clicks. Called assuming
    $input_click_client returns a value that evaluates to false. By default
    it tries to call the same method on the entity as above but on the server.
    Return values of this one are ignored. The arguments are the same, but
    the cursor position is not there (obviously).
*/
set_ext("input_click_server", func(btn, dn, x, y, z, uid) {
    if not ents { ents = import core.entities.ents }
    var ent
    if uid >= 0 { ent = ents::get(uid) }
    if ent and ent.click {
        return ent.click(btn, dn, x, y, z)
    }
})

event_map = {
    "input_click_server": true
}
}

/// Module: input
var M = {}

from std.util import assert

/**
    Sets an event callback. If the callback is not provided, the default
    callback is used (as before overriding).

    On the client you can use "yaw", "pitch", "move", "strafe", "jump",
    "crouch", "click" and "mouse_move". On the server you can use "click".
    They map to the input_EVENTNAME events above. For "click", this maps
    to $input_click_client and $input_click_server on the client and
    server respectively.

    This function returns false when no or invalid name is provided,
    true when callback is undef and the previous callback in other cases
    (undef if the callback doesn't exist - mouse_move).

    Arguments:
        - en - the event name.
        - fun - the callback.
*/
M.set_event = func(en, fun) {
    if not en {
        return false
    } else if en == "click" {
        en = @[server,"input_click_server","input_click_client"]
    } else {
        en = "input_" ~ en
    }
    var old = event_map[en]
    if not old { return false }
    if fun == undef {
        if en == "input_mouse_move" {
            unset_ext(en)
            return true
        }
        if old == true { return true }
        set_ext(en, old)
        event_map[en] = true
        return true
    }
    assert(typeof fun == "function")
    var ret = get_ext(en)
    if old == true and en != "input_mouse_move" { event_map[en] = ret }
    set_ext(en, fun)
    return ret
}

/**
    Gets an event callback. For naming, see $set_event. Returns undef if the
    name is invalid or the callback doesn't exist and the callback otherwise.
*/
M.get_event = func(en) {
    if not en {
        return undef
    } else if en == "click" {
        en = @[server,"input_click_server","input_click_client"]
    } else {
        en = "input_" ~ en
    }
    if not event_map[en] { return undef }
    return get_ext(en)
}

return M
